<h1>What is GNU Radio</h1>
<p>GNU Radio is a framework to develop software applications for the processing of radio signals. It enables users to build highly capable real-world systems that do audio processing, form mobile communication devices, track satellites, do radar and much more, all in computer software.</p>
<p>It is a highly modular, flow graph-oriented framework that comes with a comprehensive set of functionality that can be readily combined to make complex signal processing applications.</p>
<p>It is by itself not a solution to talk to any hardware, do a specific radio standard or decode a specific transmission, but it can be (and has been) used to develop implementations of basically any band-limited communication standard.</p>
<p>Examples include the decoding of aircraft security broadcasts, GSM transmission, Digital Radio Mondiale, Radar Applications as well as WiFi functionality.</p>
<h2>Digital Signal Processing</h2>
<p>As a software framework, GNU Radio works on digitized signals to generate communication functionality using general purpose computers.</p>
<h3>A little signal theory</h3>
<p>Doing signal processing in software requires the signal to be digital. But what is a digital signal?</p>
<p>To understand better, let's look at a typical scenario: Recording voice for transmission using a cellphone.</p>
<p>This starts the sound, being waves of varying air pressure, being generated by the vocal chords of a human. A time-varying physical size like the pressure is what is defined as a <em>signal</em>.</p>
<p><img src="sound_vocal.png" alt="image" /></p>
<p>When the waves reach the microphone, it converts the varying pressure into an electrical signal, a variable voltage:</p>
<p><img src="p_to_u.png" alt="image" /></p>
<p>Now that the signal is electrical, silicone chips can work with it. We call a signal like that <em>analog</em>. But a computer can't yet deal with it; for computational processing, a signal has to be <em>digital</em>, which means two things:</p>
<ol type="1">
<li>It only takes one of a limited number of values at a time, and</li>
<li>it is only being present for discrete points in time.</li>
</ol>
<p><img src="cont_to_digital.png" alt="image" /></p>
<p>This digital signal can thus be represented by a sequence of numbers, called <em>samples</em>. A fixed time interval between samples lead to a signal <em>sampling rate</em>.</p>
<p>The process of taking a physical quantity (voltage) and converting it to digital samples is done by an Analog-to-Digital Converter (ADC). The complementary device, a Digital-to-Analog Converter (DAC), takes numbers from a digital computer and converts them to an analog</p>
<p>Now that we have a sequence of numbers, our computer can do anything with it. It might, for example, apply digital filters, compress it, recognize speech or transmit the signal using a digital link.</p>
<h3>Applying Digital Signal Processing to Radio Transmissions</h3>
<p>The same principles as for sounds can be applied to radio waves:</p>
<p>A signal, here electromagnetic waves, can be converted into a varying voltage using an antenna.</p>
<p><img src="antenna.png" alt="image" /></p>
<p>This electrical signal is then on the carrier frequency, which is usually several Mega- or even Gigahertz.</p>
<p>After shifting that signal from that frequency down to zero, we get two signals that we can interpret as complex signal. We call this signal complex baseband.</p>
<p>Using two ADCs, this signal is then again converted to digital samples and can be processed in a computer.</p>
<p><img src="heterodyne.png" alt="image" /></p>
<h2>A modular, flow graph based Approach to Digital Signal Processing</h2>
<p>To process digital signals, it is very comfortable to think of the individual processing stages (filtering, correction, analysis, detection...) as processing blocks, which can be connected using sample flow-indicating arrows:</p>
<p><img src="twoblocks_arrow.png" alt="image" /></p>
<p>When building a signal processing application, one will build up a complete graph of blocks. Such a graph is called <em>flow graph</em> in the GNU Radio lingo.</p>
<p><img src="example_flowgraph.png" alt="image" /></p>
<p>GNU Radio is a framework to develop such blocks as well as building and controlling graphs of these:</p>
<p>As a GNU Radio user, you can combine existing blocks into a high-level flowgraph that does something as complex as receiving LTE modulated signals, and GNU Radio will automatically move the signal data between these and cause processing of the data when it is ready for processing.</p>
<p>GNU Radio comes with a large set of existing blocks,</p>
<p><img src="blocklist.png" alt="image" /></p>
<p>which allow you to do basic mathematical operations, synchronize your reception, generate arbitrary signals, convert between different sampling rates and do much more.</p>
<p>Also, you can write your own blocks, that either combine existing blocks with some intelligence to provide new functionality together with some logic, or you can develop your own block that operates on the input data and outputs data.</p>
<p>Thus, GNU Radio is mainly a framework for the development of signal processing blocks and their interaction. It comes with an extensive standard library of blocks, and there are a lot of systems available that a developer might build upon. However, GNU Radio itself is not a software that is ready to do something specific -- it's the user's job to build something useful out of it, though it already comes with a lot of useful working examples. Think of it as a set of building blocks.</p>
